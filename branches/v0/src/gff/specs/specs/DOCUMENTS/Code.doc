		Overview of EA IFF example source files


This source code is distributed as public domain software. Use it to help
write robust IFF-compatible programs.

Caveat: Electronic Arts developed this code, and is releasing it to promote
the success of the Amiga.  EA does not have the resources to supply support
for this code. For support, Amiga software developers contact Commodore
directly.

1. Description of the EA-provided sources and include files

	COMPILER.H	Portability file to isolate compiler idiosyncrasies.

	INTUALL .H	A super-include file for Amiga include files.

	REMALLOC.H	Header for RemAlloc subroutines.
	REMALLOC.C	Memory ALLOCators which REMember the size allocated,
			for simpler freeing.

	GIO	.H	Header file for Generic I/O speed up package.
	GIO	.C	Generic I/O speed up routines (a disk cache).
	GIOCALL .C	Outline of example GIO client.
			To turn on the GIO package, change a switch in GIO.H,
			add GIO.O to the linker control file, and recompile.

	IFF	.H	Header file for general IFF read/write support.
	IFFR	.C	IFF reader support routines.
	IFFW	.C	IFF writer support routines.
			These routines do a lot of the work for reading and
			writing IFF files robustly. The reader and writer are
			separate since some programs don't need both.

	IFFCHECK.C	IFF checker utility source (very handy for debugging).
			The IFF checker scans an IFF file, checks it for
			syntax errors, and prints an outline of its contents.

	PACKER	.H	Header for byte run encoder (compressor) subroutines.
	PACKER	.C	Run encoder subroutines.
	UNPACKER.C	Run decoder subroutines. This run encoder/decoder is
			used for ILBM raster images.

	ILBM	.H	Header for ILBM (raster image file) subroutines.
	ILBMR	.C	ILBM reader support routines. Uses IFFR.
	ILBMW	.C	ILBM writer support routines. Uses IFFW.

	READPICT.H	Header for ReadPicture subroutines.
	READPICT.C	ReadPicture subroutines read an ILBM file into an
			Amiga BitMap in RAM. Uses ILBMR and IFFR.

	SHOWILBM.C	Example program that reads and displays an ILBM file.

	PUTPICT .H	Header for PutPict subroutines.
	PUTPICT .C	PutPict subroutines write an Amiga BitMap from RAM
			to an ILBM file. Uses ILBMW and IFFW.

	RAW2ILBM.C	Example program that reads a "raw" raster image file
			and writes the image as an ILBM file.

	ILBM2Raw.C	Example program that reads an image as an ILBM file
			and writes the image as a "raw" raster image file.

	BMPrintC.C	Subroutine that actually does the text dump.
	ILBMDump.C	Example program that reads an image as an ILBM file
			and writes the image as a text file containing C data
			initialization statements for either a BOB or a
			Sprite.

2. Compiler idiosyncracies.

This source code was built for the Lattice 68000 Amiga C cross-compiler, and
the Metacomco ALink linker. Some of the IFF source code assumes that the
compiler will support function protyping: the ability to typecheck procedure
arguments (templates). Believe me, typechecking is useful! The more bugs I
find at compile time, the less I have to find at run time.

The programmer asks for this typechecking via an "extern" statement like
this:
	extern IFFP Seek(BPTR, LONG, LONG);
	typedef IFFP ClientProc(struct _GroupContext *);

Unfortunately, this chokes some C compilers. If you have such a compiler, you
have to comment out the stuff in parentheses. The above two examples become:

	extern IFFP Seek(/* BPTR, LONG, LONG */);
	typedef IFFP ClientProc(/* struct _GroupContext * */);

Don't remove the parentheses!

The header file COMPILER.H defines macros to isolate the compiler
dependencies. The macro FDwAT ("function definitions with argument types")
switches on/off the argument type declarations in the header files in this
directory.


3. RemAlloc subroutines.

The "REMembering ALLOCator" is a useful little subroutine package included
here. It saves you from having to remember the size of each node you
allocate. (Why doesn't the Amiga allocator do this?)


4. Optional buffered file I/O package GIO.

Amiga file I/O can be greatly sped up by use of a RAM buffer. So we now have
a layer of software that provides optional buffering. Some compilers may also
have such a layer, in which case ignore this one. The "option" is controlled
by changing a "#define" inside the header file GIO.H, adding GIO.O to your
link file, recompiling, and recompiling. When turned off, this layer becomes
just a layer of macro calls between the IFFR and IFFW modules and the
AmigaDOS routines they call.

This RAM buffer speeds things up when you're doing numerous small Writes
and/or Seeks while writing. The general IFF writer IFFW.C tends to do this.
It should be extended to optimize reading, too. If you are not using IFF, and
already Write in chunks of 256 bytes or more, don't bother using GIO.
